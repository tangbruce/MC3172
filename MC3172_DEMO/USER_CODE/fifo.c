/****************************************Copyright (c)************************************************************--------------File Info---------------------------------------------------------------------------------** File name     :** Descriptions  :****--------------------------------------------------------------------------------------------------------** Created date  :** Created date     : 2022-7-31** Version       : V1.0** Descriptions  :****--------------------------------------------------------------------------------------------------------** Modified by   : bruce thb** Modified date :** Version       :** Descriptions  :*********************************************************************************************************/#include "../MC3172/MC3172.h"#include "fifo.h"u8 fifo_init(fifo_t *p_fifo, u8 *p_buf, u32 buf_size, lock_f lock, unlock_f unlock ){	// Check buffer for null pointer.	if (p_buf == NULL)	{		return 1;	}	p_fifo->p_buf         = p_buf;	p_fifo->buf_size_mask = buf_size - 1;	p_fifo->read_pos      = 0;	p_fifo->write_pos     = 0;    p_fifo->lock          = lock;    p_fifo->unlock        = unlock;	return 0;}u32 fifo_length(fifo_t * p_fifo){    u32 tmp = p_fifo->read_pos;    return p_fifo->write_pos - tmp;}u8 fifo_put(fifo_t *p_fifo, u8 byte){			if (!p_fifo)		return 1;		if (fifo_length(p_fifo) <= p_fifo->buf_size_mask)	{	    p_fifo->p_buf[p_fifo->write_pos % p_fifo->buf_size_mask] = byte;	    p_fifo->write_pos++;		return 0;	}		return 1;}u8 fifo_get(fifo_t *p_fifo, u8 * p_byte){	if (!p_fifo)		return 1;	    if (fifo_length(p_fifo) != 0)    {        *p_byte = p_fifo->p_buf[p_fifo->read_pos % p_fifo->buf_size_mask];        p_fifo->read_pos++;        return 0;	}    return 1;}u8 fifo_peek(fifo_t *p_fifo, u32 index, u8 *p_byte){	if (!p_fifo)		return 1;	if (fifo_length(p_fifo) > index)	{	    *p_byte = p_fifo->p_buf[(p_fifo->read_pos + index) % p_fifo->buf_size_mask];		return 0;	}	return 1;  }void fifo_flush( fifo_t *p_fifo ){	if (!p_fifo)		return ;			p_fifo->read_pos = p_fifo->write_pos;}u8 fifo_read( fifo_t *p_fifo, u8 *p_byte_array, u32 *p_size ){		const u32 requested_len = (*p_size);	u32       index = 0;	u32       byte_count;	u32       read_size;	if (!p_fifo)		return 1;	byte_count = fifo_length(p_fifo);	read_size  = MIN(requested_len, byte_count);	(*p_size) = byte_count;	// Check if the FIFO is empty.	if (byte_count == 0)	{		return 1;	}	// Check if application has requested only the size.	if (p_byte_array == NULL)	{		return 0;	}	// Fetch bytes from the FIFO.	if ( NULL != p_fifo->lock )	    p_fifo->lock();	while (index < read_size)	{	    fifo_get(p_fifo, &p_byte_array[index++]);	}    if ( NULL != p_fifo->unlock )        p_fifo->unlock();	(*p_size) = read_size;		return 0;}u8 fifo_write(fifo_t *p_fifo, u8 const * p_byte_array, u32 * p_size){	const u32 requested_len   = (*p_size);	u32       index           = 0;	u32       available_count;	u32       write_size;	if (!p_fifo)		return 1;		available_count = p_fifo->buf_size_mask - fifo_length(p_fifo) + 1;	write_size      = MIN(requested_len, available_count);	(*p_size) = available_count;	// Check if the FIFO is FULL.	if (available_count == 0)	{		return 1;	}	// Check if application has requested only the size.	if (p_byte_array == NULL)	{		return 0;	}	//Fetch bytes from the FIFO.    if ( NULL != p_fifo->lock )        p_fifo->lock();	while (index < write_size)	{		fifo_put(p_fifo, p_byte_array[index++]);	}    if ( NULL != p_fifo->unlock )        p_fifo->unlock();	(*p_size) = write_size;	return 0;}